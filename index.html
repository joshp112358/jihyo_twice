<!doctype html>
<html>
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width">
  <title>jihyo</title>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MNIST Live Tester</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <style>
    :root { --bg:#0f1226; --panel:#171a34; --ink:#ffffff; --muted:#8c93b2; --accent:#6ee7ff; --good:#4ade80; }
    * { box-sizing: border-box }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: radial-gradient(1200px 700px at 20% 0%, #1a1e44 0%, var(--bg) 35%) fixed, var(--bg); color: #e6e8ff; }
    header { padding: 20px 16px 0; text-align: center; }
    header h1 { margin: 0; font-size: clamp(20px, 4vw, 32px); letter-spacing: 0.3px; }
    header p { margin: 6px 0 0; color: var(--muted); font-size: 14px }
    main { display: grid; gap: 16px; grid-template-columns: 1fr; max-width: 1000px; margin: 18px auto; padding: 0 16px 40px; }
    .grid { display: grid; gap: 16px; grid-template-columns: 1fr; }
    @media (min-width: 900px) { .grid { grid-template-columns: 420px 1fr } }
    .card { background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); border: 1px solid rgba(255,255,255,0.08); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .canvas-wrap { display: grid; gap: 12px; justify-items: center; }
    canvas { background: #000; border-radius: 14px; border: 2px solid rgba(255,255,255,0.18); touch-action: none; }
    .controls { display:flex; gap:8px; flex-wrap: wrap; justify-content: center; }
    button, .filelabel { background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04)); border:1px solid rgba(255,255,255,0.14); color:#e9ecff; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; font-size:14px; backdrop-filter: blur(4px); }
    button:hover, .filelabel:hover { border-color: rgba(255,255,255,0.28) }
    .accent { border-color: rgba(110,231,255,0.85); box-shadow: 0 0 0 2px rgba(110,231,255,0.25) inset }
    .muted { color: var(--muted) }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .meter { height: 10px; border-radius: 8px; background: rgba(255,255,255,0.08); overflow: hidden; flex: 1; }
    .bar { height: 100%; background: linear-gradient(90deg, var(--accent), var(--good)); width: 0%; transition: width 140ms ease-out }
    .pred { font-variant-numeric: tabular-nums; min-width: 30px; text-align: right; }
    .topline { font-size: 54px; font-weight: 800; letter-spacing: 1px; }
    .status { font-size: 13px; color: var(--muted); padding-top: 6px; }
    .small { font-size: 12px; color: var(--muted) }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; padding:2px 6px; border:1px solid rgba(255,255,255,0.2); border-radius:6px; }
    .hint { margin-top: 10px; font-size: 13px; color: var(--muted); text-align: center; }
    a { color: var(--accent); text-decoration: none }
    .drop { outline: 2px dashed rgba(255,255,255,0.15); padding:10px; border-radius:12px; text-align:center; }
    .vis-row { display:grid; grid-template-columns: repeat(14, 1fr); gap:2px; }
    .vis-cell { width: 10px; height: 10px; background: #222; border-radius: 2px; }
  </style>
</head>
<body>
  <h1>It works </h1>
  <p>We’ll add the canvas + model later.</p>
  <header>
    <h1>MNIST Live Tester</h1>
    <p>Draw a single digit (0–9). The model predicts in your browser — no server needed.</p>
  </header>
  <main>
    <div class="grid">
      <section class="card">
        <div class="canvas-wrap">
          <canvas id="board" width="280" height="280" aria-label="drawing canvas"></canvas>
          <div class="controls">
            <button id="clearBtn">Clear (<span class="kbd">C</span>)</button>
            <button id="undoBtn">Undo (<span class="kbd">Z</span>)</button>
            <button id="predictBtn" class="accent">Predict (<span class="kbd">Enter</span>)</button>
            <label class="filelabel" for="file">Upload PNG/JPG</label>
            <input id="file" type="file" accept="image/*" style="display:none" />
          </div>
          <div class="hint">Tip: draw large and centered. Thick, single stroke works best.</div>
        </div>
      </section>

      <section class="card">
        <div class="row" style="align-items:flex-end; gap: 16px;">
          <div style="flex:1;">
            <div id="topline" class="topline">–</div>
            <div id="status" class="status">Model: <span id="modelName">loading…</span></div>
          </div>
          <div style="width: 160px;">
            <canvas id="thumb" width="112" height="112" style="border-radius: 12px; border: 1px solid rgba(255,255,255,0.12);"></canvas>
            <div class="small" style="text-align:center; margin-top: 6px;">28×28 preview</div>
          </div>
        </div>
        <div id="probs" style="margin-top: 10px; display: grid; gap: 8px;"></div>
        <div id="drop" class="drop" style="margin-top:14px;">or drop an image here</div>
      </section>
    </div>

    <section class="card">
      <h3 style="margin: 0 0 8px;">How to use on GitHub Pages</h3>
      <ol style="margin:0; padding-left: 18px; line-height: 1.6;">
        <li>Create a repo (e.g. <span class="kbd">mnist-live</span>) and enable GitHub Pages (Deploy from <em>branch</em>).</li>
        <li>Add this file as <span class="kbd">index.html</span> at the repo root.</li>
        <li>Add a pre-trained TF.js MNIST model under <span class="kbd">/model/model.json</span> (with weight shards next to it). See notes below.</li>
        <li>Commit & push. Open the Pages URL and draw!</li>
      </ol>
      <p class="small" style="margin-top:8px;">Model notes: You can train a CNN on MNIST in Python/Keras, then convert to TF.js with <span class="kbd">tensorflowjs_converter</span>. Or export a pre-trained MNIST TF.js model and place its <span class="kbd">model.json</span> and <span class="kbd">group1-shard
y.bin</span> files into <span class="kbd">/model</span>.</p>
    </section>
  </main>

  <script>
    // --- Canvas drawing ---
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const thumb = document.getElementById('thumb');
    const tctx = thumb.getContext('2d');
    const probsEl = document.getElementById('probs');
    const topline = document.getElementById('topline');
    const statusEl = document.getElementById('status');
    const modelNameEl = document.getElementById('modelName');
    const drop = document.getElementById('drop');

    // Draw settings
    const stroke = { color: '#fff', size: 22, cap: 'round', join: 'round' };
    let drawing = false;
    let last = null;
    let strokes = []; // array of paths; each path is array of points
    let path = [];

    function resetCanvas() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function drawPathSegment(p0, p1) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.size;
      ctx.lineCap = stroke.cap;
      ctx.lineJoin = stroke.join;
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
    }

    function startDraw(x,y){ drawing=true; last={x,y}; path=[{x,y}]; }
    function moveDraw(x,y){ if(!drawing) return; const p={x,y}; drawPathSegment(last,p); last=p; path.push(p); }
    function endDraw(){ if(!drawing) return; drawing=false; if (path.length>1) { strokes.push(path); } path=[]; preview(); }

    // Mouse
    canvas.addEventListener('mousedown', e=>{ const r=canvas.getBoundingClientRect(); startDraw(e.clientX-r.left, e.clientY-r.top); });
    window.addEventListener('mousemove', e=>{ if(!drawing) return; const r=canvas.getBoundingClientRect(); moveDraw(e.clientX-r.left, e.clientY-r.top); });
    window.addEventListener('mouseup', endDraw);

    // Touch
    canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; const r=canvas.getBoundingClientRect(); startDraw(t.clientX-r.left, t.clientY-r.top); e.preventDefault(); },{passive:false});
    canvas.addEventListener('touchmove', e=>{ const t=e.touches[0]; const r=canvas.getBoundingClientRect(); moveDraw(t.clientX-r.left, t.clientY-r.top); e.preventDefault(); },{passive:false});
    canvas.addEventListener('touchend', endDraw);

    // Buttons
    document.getElementById('clearBtn').addEventListener('click', ()=>{ strokes=[]; resetCanvas(); preview(); });
    document.getElementById('undoBtn').addEventListener('click', ()=>{ strokes.pop(); redrawAll(); preview(); });
    document.getElementById('predictBtn').addEventListener('click', predict);

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key==='Enter') predict();
      if(e.key.toLowerCase()==='c') { strokes=[]; resetCanvas(); preview(); }
      if(e.key.toLowerCase()==='z') { strokes.pop(); redrawAll(); preview(); }
    });

    function redrawAll(){ resetCanvas(); for(const s of strokes){ for(let i=1;i<s.length;i++){ drawPathSegment(s[i-1], s[i]); } } }

    // --- Image upload / DnD ---
    document.getElementById('file').addEventListener('change', e=> handleFile(e.target.files?.[0]));
    ;['dragenter','dragover'].forEach(t=> drop.addEventListener(t, e=>{e.preventDefault(); drop.style.background='rgba(255,255,255,0.05)';}))
    ;['dragleave','drop'].forEach(t=> drop.addEventListener(t, e=>{e.preventDefault(); drop.style.background='transparent';}))
    drop.addEventListener('drop', e=>{ const f=e.dataTransfer.files?.[0]; if(f) handleFile(f); });

    function handleFile(file){ if(!file) return; const img=new Image(); img.onload=()=>{ const r=canvas.getBoundingClientRect(); const scale=Math.min(canvas.width/img.width, canvas.height/img.height); const w=img.width*scale, h=img.height*scale; resetCanvas(); ctx.drawImage(img, (canvas.width-w)/2, (canvas.height-h)/2, w, h); strokes=[]; preview(); }; img.src=URL.createObjectURL(file); }

    // --- Preprocess to 28x28 ---
    function get28x28(){
      // Crop to bounding box of drawn ink to reduce extra margins
      const src = ctx.getImageData(0,0,canvas.width,canvas.height);
      const {data, width, height} = src;
      let minX=width, minY=height, maxX=0, maxY=0, found=false;
      for(let y=0;y<height;y++){
        for(let x=0;x<width;x++){
          const i=(y*width+x)*4; // white ink on black bg
          const v = data[i]; // red channel is enough
          if(v>10){ // threshold of ink
            found=true; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y;
          }
        }
      }
      // If nothing drawn, return blank 28x28
      if(!found){ const out = document.createElement('canvas'); out.width=28; out.height=28; const octx=out.getContext('2d'); octx.fillStyle='#000'; octx.fillRect(0,0,28,28); return out; }

      const bw=maxX-minX+1, bh=maxY-minY+1;
      // Make square box, add padding
      const size=Math.max(bw,bh);
      const pad = Math.round(size*0.20);
      const boxSize = size + pad*2;
      const box = document.createElement('canvas'); box.width = boxSize; box.height = boxSize; const bctx=box.getContext('2d');
      bctx.fillStyle='#000'; bctx.fillRect(0,0,boxSize,boxSize);
      bctx.drawImage(canvas, minX-pad, minY-pad, boxSize, boxSize, 0, 0, boxSize, boxSize);

      // Resize to 28x28 using nearest-neighbor to preserve edges
      const out = document.createElement('canvas'); out.width=28; out.height=28; const octx=out.getContext('2d');
      octx.imageSmoothingEnabled = false;
      octx.drawImage(box, 0,0,28,28);
      return out;
    }

    function preview(){
      const c = get28x28();
      // upscale preview 4x
      tctx.imageSmoothingEnabled = false;
      tctx.fillStyle = '#000'; tctx.fillRect(0,0,thumb.width,thumb.height);
      tctx.drawImage(c, 0, 0, c.width, c.height, 0, 0, thumb.width, thumb.height);
    }

    // --- TF.js model loading ---
    let model = null;
    async function loadModel(){
      try {
        model = await tf.loadLayersModel('./model/model.json');
        modelNameEl.textContent = model?.name || 'mnist-cnn';
        statusEl.innerHTML = `Model: <span id="modelName">${model?.name || 'mnist-cnn'}</span>`;
      } catch(err){
        modelNameEl.textContent = 'Not found (place model at /model/model.json)';
        console.error(err);
      }
    }

    // --- Prediction ---
    function speak(text){
      try { const u = new SpeechSynthesisUtterance(String(text)); u.lang = 'en-US'; u.rate = 1.0; u.pitch = 1.0; speechSynthesis.cancel(); speechSynthesis.speak(u); } catch {}
    }

    async function predict(){
      preview();
      if(!model){ topline.textContent='–'; statusEl.textContent='Model not loaded. Place it at /model/model.json'; return; }

      const c = get28x28();
      const tmp = document.createElement('canvas'); tmp.width=28; tmp.height=28; const x=tmp.getContext('2d');
      x.drawImage(c, 0,0);
      const img = x.getImageData(0,0,28,28);
      const input = tf.tidy(()=>{
        // Convert to grayscale [0,1], invert (MNIST is white digit on black)
        const buf = new Float32Array(28*28);
        for(let i=0;i<28*28;i++){
          const r = img.data[i*4+0];
          const g = img.data[i*4+1];
          const b = img.data[i*4+2];
          const a = img.data[i*4+3]/255;
          const gray = (0.299*r + 0.587*g + 0.114*b)/255 * a;
          buf[i] = gray; // already 0..1 on black background
        }
        // Normalize
        const t = tf.tensor(buf, [1,28,28,1]);
        return t;
      });

      const logits = model.predict(input);
      const probs = (await logits.data()).slice();
      tf.dispose([logits, input]);

      const arr = [...probs].map((p,i)=>({digit:i, p})).sort((a,b)=>b.p-a.p);
      const top = arr.slice(0,5);
      const pred = top[0].digit;

      topline.textContent = String(pred);
      statusEl.textContent = `Top-1 confidence: ${(top[0].p*100).toFixed(1)}%`;
      speak(pred);

      // Render bars
      probsEl.innerHTML = '';
      for(const {digit,p} of arr){
        const row = document.createElement('div'); row.className='row';
        const lab = document.createElement('div'); lab.textContent = digit; lab.style.minWidth='18px'; lab.style.textAlign='center';
        const meter = document.createElement('div'); meter.className='meter';
        const bar = document.createElement('div'); bar.className='bar'; bar.style.width = `${(p*100).toFixed(1)}%`;
        const predp = document.createElement('div'); predp.className='pred'; predp.textContent = `${(p*100).toFixed(1)}%`;
        meter.appendChild(bar); row.append(lab, meter, predp); probsEl.appendChild(row);
      }
    }

    // Init
    resetCanvas(); preview(); loadModel();
  </script>
</body>
</html>

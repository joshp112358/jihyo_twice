<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MNIST Live Tester</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <style>
    :root { --bg:#2a1520; --panel:#3a1e2a; --ink:#ffe9f2; --muted:#f6c4d1; --accent:#ff8fb1; --good:#f7a8c2; }
    * { box-sizing: border-box }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: radial-gradient(1200px 700px at 20% 0%, #4a2332 0%, var(--bg) 35%) fixed, var(--bg); color: var(--ink); }
    header { padding: 20px 16px 0; text-align: center; }
    header h1 { margin: 0; font-size: clamp(20px, 4vw, 32px); letter-spacing: 0.3px; }
    header p { margin: 6px 0 0; color: var(--muted); font-size: 14px }
    main { display: grid; gap: 16px; grid-template-columns: 1fr; max-width: 1000px; margin: 18px auto; padding: 0 16px 40px; }
    .grid { display: grid; gap: 16px; grid-template-columns: 1fr; }
    @media (min-width: 900px) { .grid { grid-template-columns: 420px 1fr } }
    .card { background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); border: 1px solid rgba(255,255,255,0.08); border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .canvas-wrap { display: grid; gap: 12px; justify-items: center; }
    canvas { background: #000; border-radius: 14px; border: 2px solid rgba(255,255,255,0.18); touch-action: none; }
    .controls { display:flex; gap:8px; flex-wrap: wrap; justify-content: center; }
    button, .filelabel { background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.04)); border:1px solid rgba(255,255,255,0.14); color:#e9ecff; padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; font-size:14px; backdrop-filter: blur(4px); }
    button:hover, .filelabel:hover { border-color: rgba(255,255,255,0.28) }
    .accent { border-color: rgba(110,231,255,0.85); box-shadow: 0 0 0 2px rgba(110,231,255,0.25) inset }
    .muted { color: var(--muted) }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .meter { height: 10px; border-radius: 8px; background: rgba(255,255,255,0.08); overflow: hidden; flex: 1; }
    .bar { height: 100%; background: linear-gradient(90deg, var(--accent), var(--good)); width: 0%; transition: width 140ms ease-out }
    .pred { font-variant-numeric: tabular-nums; min-width: 30px; text-align: right; }
    .topline { font-size: 54px; font-weight: 800; letter-spacing: 1px; }
    .status { font-size: 13px; color: var(--muted); padding-top: 6px; }
    .small { font-size: 12px; color: var(--muted) }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; padding:2px 6px; border:1px solid rgba(255,255,255,0.2); border-radius:6px; }
    .hint { margin-top: 10px; font-size: 13px; color: var(--muted); text-align: center; }
    a { color: var(--accent); text-decoration: none }
    
    .vis-row { display:grid; grid-template-columns: repeat(14, 1fr); gap:2px; }
    .vis-cell { width: 10px; height: 10px; background: #222; border-radius: 2px; }
  </style>
</head>
<body>
  <header>
    <h1>MNIST Live Tester</h1>
    <p>Draw a single digit (0–9). The model predicts in your browser — no server needed.</p>
  </header>
  <main>
    <div class="grid">
      <section class="card">
        <div class="canvas-wrap">
          <canvas id="board" width="280" height="280" aria-label="drawing canvas"></canvas>
          <div class="controls">
            <button id="clearBtn">Clear (<span class="kbd">C</span>)</button>
            <button id="undoBtn">Undo (<span class="kbd">Z</span>)</button>
            <button id="predictBtn" class="accent">Predict (<span class="kbd">Enter</span>)</button>
            
          </div>
          <div class="hint">Tip: draw large and centered. Thick, single stroke works best.</div>
        </div>
      </section>

      <section class="card">
        <div class="row" style="align-items:flex-end; gap: 16px;">
          <div style="flex:1;">
            <div id="topline" class="topline">–</div>
            <div id="status" class="status">Model: <span id="modelName">loading…</span></div>
          </div>
          <div style="width: 160px;">
            <canvas id="thumb" width="112" height="112" style="border-radius: 12px; border: 1px solid rgba(255,255,255,0.12);"></canvas>
            <div class="small" style="text-align:center; margin-top: 6px;">28×28 preview</div>
          </div>
        </div>
        <div id="probs" style="margin-top: 10px; display: grid; gap: 8px;"></div>
        
      </section>
    </div>

    
  </main>

  <script>
    // --- Canvas drawing ---
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const thumb = document.getElementById('thumb');
    const tctx = thumb.getContext('2d');
    const probsEl = document.getElementById('probs');
    const topline = document.getElementById('topline');
    const statusEl = document.getElementById('status');
    const modelNameEl = document.getElementById('modelName');
    

    // Draw settings
    const stroke = { color: '#fff', size: 22, cap: 'round', join: 'round' };
    let drawing = false;
    let last = null;
    let strokes = []; // array of paths; each path is array of points
    let path = [];

    function resetCanvas() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function drawPathSegment(p0, p1) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = stroke.size;
      ctx.lineCap = stroke.cap;
      ctx.lineJoin = stroke.join;
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
    }

    function startDraw(x,y){ drawing=true; last={x,y}; path=[{x,y}]; }
    function moveDraw(x,y){ if(!drawing) return; const p={x,y}; drawPathSegment(last,p); last=p; path.push(p); }
    function endDraw(){ if(!drawing) return; drawing=false; if (path.length>1) { strokes.push(path); } path=[]; preview(); }

    // Mouse
    canvas.addEventListener('mousedown', e=>{ const r=canvas.getBoundingClientRect(); startDraw(e.clientX-r.left, e.clientY-r.top); });
    window.addEventListener('mousemove', e=>{ if(!drawing) return; const r=canvas.getBoundingClientRect(); moveDraw(e.clientX-r.left, e.clientY-r.top); });
    window.addEventListener('mouseup', endDraw);

    // Touch
    canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; const r=canvas.getBoundingClientRect(); startDraw(t.clientX-r.left, t.clientY-r.top); e.preventDefault(); },{passive:false});
    canvas.addEventListener('touchmove', e=>{ const t=e.touches[0]; const r=canvas.getBoundingClientRect(); moveDraw(t.clientX-r.left, t.clientY-r.top); e.preventDefault(); },{passive:false});
    canvas.addEventListener('touchend', endDraw);

    // Buttons
    document.getElementById('clearBtn').addEventListener('click', ()=>{ strokes=[]; resetCanvas(); preview(); });
    document.getElementById('undoBtn').addEventListener('click', ()=>{ strokes.pop(); redrawAll(); preview(); });
    document.getElementById('predictBtn').addEventListener('click', predict);

    // Keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key==='Enter') predict();
      if(e.key.toLowerCase()==='c') { strokes=[]; resetCanvas(); preview(); }
      if(e.key.toLowerCase()==='z') { strokes.pop(); redrawAll(); preview(); }
    });

    function redrawAll(){ resetCanvas(); for(const s of strokes){ for(let i=1;i<s.length;i++){ drawPathSegment(s[i-1], s[i]); } } }

    // (Upload & drag-and-drop removed for simplicity)
    // --- Preprocess to 28x28 ---
    function get28x28(){
      // Crop to bounding box of drawn ink to reduce extra margins
      const src = ctx.getImageData(0,0,canvas.width,canvas.height);
      const {data, width, height} = src;
      let minX=width, minY=height, maxX=0, maxY=0, found=false;
      for(let y=0;y<height;y++){
        for(let x=0;x<width;x++){
          const i=(y*width+x)*4; // white ink on black bg
          const v = data[i]; // red channel is enough
          if(v>10){ // threshold of ink
            found=true; if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y;
          }
        }
      }
      // If nothing drawn, return blank 28x28
      if(!found){ const out = document.createElement('canvas'); out.width=28; out.height=28; const octx=out.getContext('2d'); octx.fillStyle='#000'; octx.fillRect(0,0,28,28); return out; }

      const bw=maxX-minX+1, bh=maxY-minY+1;
      // Make square box, add padding
      const size=Math.max(bw,bh);
      const pad = Math.round(size*0.20);
      const boxSize = size + pad*2;
      const box = document.createElement('canvas'); box.width = boxSize; box.height = boxSize; const bctx=box.getContext('2d');
      bctx.fillStyle='#000'; bctx.fillRect(0,0,boxSize,boxSize);
      bctx.drawImage(canvas, minX-pad, minY-pad, boxSize, boxSize, 0, 0, boxSize, boxSize);

      // Resize to 28x28 using nearest-neighbor to preserve edges
      const out = document.createElement('canvas'); out.width=28; out.height=28; const octx=out.getContext('2d');
      octx.imageSmoothingEnabled = false;
      octx.drawImage(box, 0,0,28,28);
      return out;
    }

    function preview(){
      const c = get28x28();
      // upscale preview 4x
      tctx.imageSmoothingEnabled = false;
      tctx.fillStyle = '#000'; tctx.fillRect(0,0,thumb.width,thumb.height);
      tctx.drawImage(c, 0, 0, c.width, c.height, 0, 0, thumb.width, thumb.height);
    }

    // --- TF.js model loading ---
    let model = null;
    async function loadModel(){
      const remote = 'https://hpssjellis.github.io/beginner-tensorflowjs-examples-in-javascript/saved-models/mnist/convnet/my-mnist01.json';
      const local = './model/model.json';
      try {
        model = await tf.loadLayersModel(remote);
        const name = (model && model.name) ? model.name : 'mnist-cnn';
        modelNameEl.textContent = name + ' (remote)';
        statusEl.innerHTML = `Model: <span id="modelName">${name} (remote)</span>`;
      } catch(err1){
        console.warn('Remote model load failed, trying local /model/model.json', err1);
        try {
          model = await tf.loadLayersModel(local);
          const name = (model && model.name) ? model.name : 'mnist-cnn';
          modelNameEl.textContent = name + ' (local)';
          statusEl.innerHTML = `Model: <span id=\"modelName\">${name} (local)</span>`;
        } catch(err2){
          model = null;
          modelNameEl.textContent = 'Model not found';
          statusEl.textContent = 'Model not found. Remote + local failed. Check console.';
          console.error('Both remote and local model loads failed', err2);
        }
      }
    }</span>`;
      } catch(err){
        modelNameEl.textContent = 'Not found (place model at /model/model.json)';
        console.error(err);
      }
    }

    // --- Prediction ---
    function speak(text){
      try { const u = new SpeechSynthesisUtterance(String(text)); u.lang = 'en-US'; u.rate = 1.0; u.pitch = 1.0; speechSynthesis.cancel(); speechSynthesis.speak(u); } catch {}
    }

    async function predict(){
      preview();
      if(!model){ topline.textContent='–'; statusEl.textContent='Model not loaded. Place it at /model/model.json'; return; }

      const c = get28x28();
      const tmp = document.createElement('canvas'); tmp.width=28; tmp.height=28; const x=tmp.getContext('2d');
      x.drawImage(c, 0,0);
      const img = x.getImageData(0,0,28,28);
      const input = tf.tidy(()=>{
        // Convert to grayscale [0,1], invert (MNIST is white digit on black)
        const buf = new Float32Array(28*28);
        for(let i=0;i<28*28;i++){
          const r = img.data[i*4+0];
          const g = img.data[i*4+1];
          const b = img.data[i*4+2];
          const a = img.data[i*4+3]/255;
          const gray = (0.299*r + 0.587*g + 0.114*b)/255 * a;
          buf[i] = gray; // already 0..1 on black background
        }
        // Normalize
        const t = tf.tensor(buf, [1,28,28,1]);
        return t;
      });

      const logits = model.predict(input);
      const probs = (await logits.data()).slice();
      tf.dispose([logits, input]);

      const arr = [...probs].map((p,i)=>({digit:i, p})).sort((a,b)=>b.p-a.p);
      const top = arr.slice(0,5);
      const pred = top[0].digit;

      topline.textContent = String(pred);
      statusEl.textContent = `Top-1 confidence: ${(top[0].p*100).toFixed(1)}%`;
      speak(pred);

      // Render bars
      probsEl.innerHTML = '';
      for(const {digit,p} of arr){
        const row = document.createElement('div'); row.className='row';
        const lab = document.createElement('div'); lab.textContent = digit; lab.style.minWidth='18px'; lab.style.textAlign='center';
        const meter = document.createElement('div'); meter.className='meter';
        const bar = document.createElement('div'); bar.className='bar'; bar.style.width = `${(p*100).toFixed(1)}%`;
        const predp = document.createElement('div'); predp.className='pred'; predp.textContent = `${(p*100).toFixed(1)}%`;
        meter.appendChild(bar); row.append(lab, meter, predp); probsEl.appendChild(row);
      }
    }

    // Init
    resetCanvas(); preview(); loadModel();
  </script>
</body>
</html>
